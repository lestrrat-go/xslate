/*

Package vm implements the virtual machine used to run the bytecode
generated by http://github.com/lestrrat-go/xslate/compiler

The virtual machine is an extremely simple one: each opcode in the
bytecode sequence returns the next opcode to execute. The virtual machine
just keeps on calling the opcode until we reach the "end" opcode.

The virtual machine accepts the bytecode, and input variables:

  vm.Run(bytecode, variables)

*/
package vm

import (
	"bufio"
	"fmt"
	"io"

	"github.com/lestrrat-go/xslate/internal/rvpool"
)

// NewVM creates a new VM
func NewVM() *VM {
	return &VM{
		st:        NewState(),
		functions: nil,
		Loader:    nil,
	}
}

func (vm *VM) SetFunctions(vars Vars) {
	vm.functions = vars
}

// CurrentOp returns the current Op to be executed
func (vm *VM) CurrentOp() Op {
	return vm.st.CurrentOp()
}

// IsSupportedByteCodeVersion returns true if this VM can handle the
// provided bytecode version
func (vm *VM) IsSupportedByteCodeVersion(bc *ByteCode) bool {
	return bc.Version == 1.0
}

// Run executes the given vm.ByteCode using the given variables. For historical
// reasons, it also allows re-executing the previous bytecode instructions
// given to a virtual machine, but this will probably be removed in the future
func (vm *VM) Run(bc *ByteCode, vars Vars, output io.Writer) {
	if !vm.IsSupportedByteCodeVersion(bc) {
		panic(fmt.Sprintf(
			"error: ByteCode version %f no supported",
			bc.Version,
		))
	}

	st := vm.st

	if _, ok := output.(*bufio.Writer); !ok {
		output = bufio.NewWriter(output)
		defer output.(*bufio.Writer).Flush()
	}
	st.Reset()
	st.pc = bc
	st.output = output
	newvars := Vars(rvpool.Get())
	defer rvpool.Release(newvars)
	defer newvars.Reset()

	st.vars = newvars
	if fc := vm.functions; fc != nil {
		for k, v := range vm.functions {
			st.vars[k] = v
		}
	}

	if vars != nil {
		for k, v := range vars {
			st.vars[k] = v
		}
	}
	st.Loader = vm.Loader

	// This is the main loop
	for op := st.CurrentOp(); op.Type() != TXOPEnd; op = st.CurrentOp() {
		op.Call(st)
	}
}
